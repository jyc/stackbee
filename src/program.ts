import { intToSubs, range, shuffle, unreachable } from "lib";

export const CHOICE_COUNT = 4;
const EXAMPLE_COUNT = 2;
const MAX_SEED = 12;
const MAX_TERM = 144;
const MIN_UNIQUE_TERMS = 4;
export const SUFFIX_LEN = 6;

// Note: this can't be changed without updating problem set generation, which indexes sequences by
// their seeds.
export const SEED_LEN = 2;

export interface Trace {
  ops: SymVal[];
  stack: Rat[];
}

export interface SymTrace {
  ops: Op[];
  stack: SymStack;
}

export interface ProgramAndExample {
  hex: string;
  seq: number[];
}

export interface Problem {
  hex: string;
  examples: number[][];
  correct: number[];
  incorrects: ProgramAndExample[];
}

export type ProblemSet = { [hex: string]: Problem };

export async function makeProblemSet({
  onProgress,
  maxEnumHexCount,
  problemCount,
}: {
  onProgress: (progress: number) => Promise<void>;
  maxEnumHexCount: number;
  problemCount: number;
}): Promise<ProblemSet> {
  // We want to construct a problem for each program like so:
  //
  // > Here are {EXAMPLE_COUNT} example number sequences: ...
  // >
  // > Which of the following sequences follows the same pattern?
  // > A) ...
  // > B) ...
  // > ...
  //
  // All of the CHOICE_COUNT sequences should start with the same seed.
  //
  // 1. Reject "boring" programs:
  //    - programs that are surely constant (e.g. `0`)
  //    - programs that only return 1 symbolic expression of size 1 (e.g. `dup`)
  // 1. Evaluate each program on seeds between [1, 12]^SEQUENCE_SEED_COUNT
  // 2. Reject programs that do not have at least EXAMPLE_COUNT+1 sequences
  //    which are all whole numbers
  // 3. Reject programs whose whole number sequences ("trace") are all
  //    identical to another sequence's trace
  // 3. Choose EXAMPLE_COUNT sequences as examples, choose 1 sequence as the
  //    correct answer
  // 4. Find CHOICE_COUNT-1 other sequences for incorrect answers; check for
  //    the sequences generated by the same seed in the correct sequence when
  //    used as the input to other programs.
  //    Reject programs where we cannot find sufficient incorrect answers.

  // `examples[hex][MAX_SEED * (a-1) + (b-1)]` is the sequence generated by evaluating
  // the program `hex` on the initial stack `a b` if the sequence consists of
  // only whole numbers, or [] otherwise.
  const examples: { [hex: string]: number[][] } = {};
  // `traces[trace] = hex` where `hex` is a program and `trace` is
  // `JSON.stringify(examples[hex])`.
  const traces = new Map<string, string>();
  const tops = new Map<string, string>();
  const filtered: string[] = [];

  const test = (hex: string): boolean => {
    const symStack = SymStack.fromProgramHex(hex);

    const isBoring = SymStack.isBoring(symStack);
    if (isBoring) {
      // console.log("boring", hex);
      return false;
    }
    const isConfusing = SymStack.isConfusing(symStack);
    if (isConfusing) {
      // console.log("confusing", hex);
      return false;
    }

    const top = SymStack.top(symStack);
    const topString = !top ? "" : top.map(unparse).toSorted().join(", ");
    const otherTopHex = tops.get(topString);
    if (otherTopHex) {
      // console.log(
      //   `rejecting ${hex} for having the same top SymExprSet as ${otherTopHex}: ${topString}`,
      // );
      return false;
    }

    const ops = hexToOps(hex);
    examples[hex] = [];
    let exampleCount = 0;
    const traceTerms = new Set<number>();
    for (let a = 1; a <= MAX_SEED; a++) {
      for (let b = 1; b <= MAX_SEED; b++) {
        // TODO factor out of this and evaluateSequence?
        const sequence = [a, b];
        let stack = [...sequence.map(int)];
        const seqTerms = new Set<number>();
        let ok = true;
        for (let i = 0; i < SUFFIX_LEN; i++) {
          evaluate(ops, stack);
          const top = stack.pop() ?? ZERO;
          if (!isInt(top) || isNaN(top[0]) || Math.abs(top[0]) > MAX_TERM) {
            ok = false;
            break;
          }
          const t = top[0];
          sequence.push(t);
          seqTerms.add(t);
          traceTerms.add(t);
          stack = [...sequence.map(int)];
        }

        if (ok && seqTerms.size >= MIN_UNIQUE_TERMS) {
          examples[hex].push(sequence);
          exampleCount++;
        } else {
          examples[hex].push([]);
        }
      }
    }

    // We are guaranteed at least MAX_SEED unique terms from the sequence
    // seed [1..MAX_SEED].
    // We want an average of MIN_UNIQUE_SEQUENCE_TERMS additional unique terms
    // per sequence.
    if (traceTerms.size < MAX_SEED + MIN_UNIQUE_TERMS * MAX_SEED) {
      return false;
    }

    if (exampleCount < EXAMPLE_COUNT + 1) {
      // console.log(`rejecting ${hex} for not having enough whole-number sequences`);
      return false;
    }

    const trace = JSON.stringify(examples[hex]);
    const otherTraceHex = traces.get(trace);
    if (otherTraceHex) {
      // console.log(`rejecting ${hex} for having the same trace as ${otherTraceHex}`);
      return false;
    }

    traces.set(trace, hex);
    tops.set(topString, hex);
    return true;
  };

  const PROGRESS_REPORT_INTERVAL = 1 << 5;
  const TEST_PROGRESS_FRACTION = 0.75;

  // TODO Factor out into sampleFilterMap function?
  console.log({ maxEnumHexCount, filterLimit: problemCount });
  if (maxEnumHexCount < 1 << 20) {
    console.log("shuffling");
    const programs = range(0, maxEnumHexCount);
    shuffle(programs);
    for (let i = 0; i < programs.length && filtered.length < problemCount; i++) {
      const n = programs[i];
      const hex = n.toString(16);
      if (!test(hex)) {
        continue;
      }
      filtered.push(hex);
      if (i % PROGRESS_REPORT_INTERVAL === 0) {
        await onProgress((filtered.length / problemCount) * TEST_PROGRESS_FRACTION);
      }
    }
  } else {
    console.log("sampling");
    const checked = new Set<number>();
    let failedAttempts = 0;
    let i = 0;
    while (filtered.length < problemCount) {
      console.log(failedAttempts);
      if (failedAttempts > 0.5 * maxEnumHexCount) {
        console.error("failed to find a new program after multiple attempts; giving up");
        break;
      }
      // I'm pretty sure this should not be biased towards particular numbers in
      // [0, maxEnumHexCount) because MAX_PROGRAM_LEN guarantees that
      // maxEnumHexCount < MAX_SAFE_INTEGER.
      const n = Math.floor(Math.random() * maxEnumHexCount);
      if (checked.has(n)) {
        failedAttempts++;
        continue;
      }
      checked.add(n);
      const hex = n.toString(16);
      if (!test(hex)) {
        failedAttempts++;
        continue;
      }
      filtered.push(hex);
      failedAttempts = 0;
      if (i++ % PROGRESS_REPORT_INTERVAL === 0) {
        await onProgress((filtered.length / problemCount) * TEST_PROGRESS_FRACTION);
      }
    }
  }

  const problems: { [hex: string]: Problem } = {};
  let i = 0;
  for (const hex of filtered) {
    const sequences = examples[hex].filter((s) => s.length);
    if (sequences.length < EXAMPLE_COUNT + 1) {
      throw Error(
        `${hex} should have been rejected for having insufficiently many whole-number sequences`,
      );
    }

    shuffle(sequences);
    const correct = sequences.pop()!;

    const otherPrograms = [...filtered];
    shuffle(otherPrograms);

    const intArrayEq = (a: number[], b: number[]): boolean => {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    };

    const incorrects: ProgramAndExample[] = [];
    for (const otherHex of otherPrograms) {
      const otherExamples = examples[otherHex];
      // This depends on `SEED_LEN`.
      const seqIdx = MAX_SEED * (correct[0] - 1) + (correct[1] - 1);
      const otherSeq = otherExamples[seqIdx];

      if (
        otherSeq.length > 0 &&
        !intArrayEq(otherSeq, correct) &&
        incorrects.every((incorrect) => !intArrayEq(otherSeq, incorrect.seq))
      ) {
        incorrects.push({ hex: otherHex, seq: otherSeq });
        if (Object.keys(incorrects).length >= CHOICE_COUNT - 1) {
          break;
        }
      }
    }

    if (incorrects.length < CHOICE_COUNT - 1) {
      // synthesize incorrect answers?
      console.error(`failed to find ${CHOICE_COUNT - 1} incorrect answers for ${hex}`);
    }

    const problem: Problem = {
      hex,
      examples: sequences.slice(0, EXAMPLE_COUNT),
      correct,
      incorrects,
    };
    problems[hex] = problem;

    if (i++ % PROGRESS_REPORT_INTERVAL === 0) {
      await onProgress(
        TEST_PROGRESS_FRACTION + (i / filtered.length) * (1 - TEST_PROGRESS_FRACTION),
      );
    }
  }

  return problems;
}

export function evaluateSequence(hex: string, seed: number[]): number[] {
  const sequence = [...seed];
  const ops = hexToOps(hex);

  for (let i = 0; i < SUFFIX_LEN; i++) {
    const stack = [...sequence.map(int)];
    evaluate(ops, stack);

    const top = stack.pop() ?? ZERO;
    if (!isInt(top) || isNaN(top[0]) || Math.abs(top[0]) > MAX_TERM) {
      throw Error("top was invalid: " + top);
    }
    const t = top[0];
    sequence.push(t);
  }

  return sequence;
}

export type Rat = readonly [number, number];

export const ONE = [1, 1] as const;
export const ZERO = [0, 1] as const;

function gcd(a: number, b: number): number {
  while (b !== 0) {
    if (isNaN(a) || isNaN(b)) {
      return NaN;
    }
    const t = b;
    b = a % b;
    a = t;
  }
  return a;
}

export function int(a: number): Rat {
  return [a, 1];
}

export function isInt(a: Rat): boolean {
  return a[1] === 1;
}

export function simplify(a: number, b: number): Rat {
  if (isNaN(a)) {
    return [NaN, NaN];
  }
  if (a === 0 || b === 0) {
    // We could represent infinity as [1, 0].
    // For now have n/0 = 0.
    return [0, 1];
  }
  if (b < 0) {
    a *= -1;
    b *= -1;
  }
  const d = gcd(Math.abs(a), Math.abs(b));
  return [a / d, b / d];
}

function add(a: Rat, b: Rat): Rat {
  return simplify(a[0] * b[1] + b[0] * a[1], a[1] * b[1]);
}

function sub(a: Rat, b: Rat): Rat {
  return simplify(a[0] * b[1] - b[0] * a[1], a[1] * b[1]);
}

function mul(a: Rat, b: Rat): Rat {
  return simplify(a[0] * b[0], a[1] * b[1]);
}

function div(a: Rat, b: Rat): Rat {
  if (b[0] === 0) {
    return [0, 1];
  }
  return simplify(a[0] * b[1], a[1] * b[0]);
}

function mod(a: Rat, b: Rat): Rat {
  if (b[0] === 0) {
    return [0, 1];
  }
  return simplify((a[0] * b[1]) % (a[1] * b[0]), a[1] * b[1]);
}

function gtz(n: Rat): boolean {
  return n[0] > 0;
}

export function eq(a: Rat, b: Rat): boolean {
  return a[0] === b[0] && a[1] === b[1];
}

export function showRat(x: Rat): string {
  if (isInt(x)) {
    return x[0].toString();
  }
  return `${x[0]}/${x[1]}`;
}

export function parseRatList(input: string): Rat[] {
  return input
    .split(/[\s,]+/)
    .filter((x) => x.length > 0)
    .flatMap((x): Rat[] => {
      const match = x.match(/^([0-9-]+)\/([0-9-]+)$/);
      if (match) {
        const p = +match[1];
        const q = +match[2];
        if (isNaN(p) || isNaN(q)) {
          // TODO Show some error for invalid numbers
          return [];
        }
        return [simplify(p, q)];
      } else {
        return [int(Math.floor(+x))];
      }
    });
}

export type Op =
  | 0
  | 1
  | 2
  | 3
  | "+" // 4
  | "-" // 5
  | "*" // 6 (six → (s)tar)
  | "/" // 7 (7 → /)
  | "%" // 8 (8 → .. → ./. → %)
  | "dup" // 9
  | "drop" // a
  | "swap" // b
  | "rot" // c; right top, rot CCW
  | "unrot" // d
  | "len" // l(e)n
  | "bgtz"; // i(f)

const OPS: Op[] = [
  0,
  1,
  2,
  3,
  "+",
  "-",
  "*",
  "/",
  "%",
  "dup",
  "drop",
  "swap",
  "rot",
  "unrot",
  "len",
  "bgtz",
];

const OPCODES = Object.fromEntries(OPS.map((x, i) => [x, i]));

interface Token {
  word: string;
  col: number;
}

interface Lexer {
  next(): Token;
  peek(): Token | null;
  expect(word: string): Token;
}

function error(message: string, col: number): never {
  throw Error(`${col + 1}: ${message}`);
}

function quote(token: Token): string {
  if (token.word === null) {
    return "EOF";
  } else {
    return JSON.stringify(token.word);
  }
}

function parseWithLexer(lexer: Lexer): Op[] {
  // dup 2 mod if { 3 mul 1 add } else { 2 div }
  // dup 2 mod if(4,2) 3 mul 1 add 2 div
  const out: Op[] = [];
  const token = lexer.next();
  if (token.word.match(/^[0-9]+$/)) {
    const number = parseInt(token.word, 10);
    if (number >= 16) {
      error(`expected number to be between 0 and 15; got ${quote(token)}`, token.col);
    }
    out.push(OPS[number]);
  } else {
    switch (token.word) {
      case "+":
      case "-":
      case "*":
      case "/":
      case "%":
      case "dup":
      case "drop":
      case "swap":
      case "rot":
      case "unrot":
      case "len":
      case "bgtz":
        out.push(token.word);
        break;
      default:
        error(`unexpected ${quote(token)}`, token.col);
    }
  }

  return out;
}

export function parse(text: string): Op[] {
  // Use a clever trick from: https://github.com/evanw/kiwi/blob/fe3ca9484ac055ccd39fe144218ec11f720222ae/js/parser.ts#L21C13-L21C96
  //
  // (token1|token2|...)
  // Wrapping the whole regex in a capturing group causes split() to return the
  // tokens, not just the (empty) boundaries between tokens:
  // ["", "token1", "", "token2", ...]
  // Why not match(/.../g)? If there's an invalid token in between some valid
  // tokens, we want to see it so that we can report a syntax error; match would
  // just keep matching afterwards.
  const parts = text.split(/([+\-*/%]|\b[a-z]+\b|\b[0-9]+\b|\s+)/g);
  const tokens: Token[] = [];
  let col = 0;
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    if (i & 1) {
      if (part.trim().length > 0) {
        tokens.push({
          word: part,
          col,
        });
      }
      col += part.length;
    } else if (part !== "") {
      error(`syntax error: ${JSON.stringify(part)}`, col);
    }
  }

  let i = 0;
  const lexer: Lexer = {
    next() {
      if (i >= tokens.length) {
        error("unexpected EOF", col);
      }
      return tokens[i++];
    },
    peek() {
      if (i >= tokens.length) {
        return null;
      }
      return tokens[i];
    },
    expect(word: string) {
      if (i >= tokens.length) {
        error("unexpected EOF", col);
      }
      if (tokens[i].word !== word) {
        error(`expected ${JSON.stringify(word)}, got: ${quote(tokens[i])}`, col);
      }
      return tokens[i++];
    },
  };

  const ops: Op[] = [];
  while (i < tokens.length) {
    ops.push(...parseWithLexer(lexer));
  }
  return ops;
}

export function unparse(ops: SymVal[]): string {
  const words = [];
  let afterBgtz = false;
  for (const op of ops) {
    if (isSymbol(op)) {
      const [k, n] = op;
      words.push(SymKind.show(k) + intToSubs(n));
    } else if (afterBgtz) {
      afterBgtz = false;
      words.push(OPCODES[op as Op].toString());
    } else {
      words.push(op.toString());
      if (op === "bgtz") {
        afterBgtz = true;
      }
    }
  }
  return words.join(" ");
}

function isSymbol(val: SymVal): val is Sym {
  return Array.isArray(val);
}

export function hexToOps(hex: string): Op[] {
  return hex.split("").map((h) => {
    const code = parseInt(h, 16);
    if (isNaN(code)) {
      throw Error(`invalid hex: ${h}`);
    }
    if (code < 0 || code >= 16) {
      throw Error(`invalid opcode: ${code}`);
    }
    return OPS[code];
  });
}

export function opsToHex(ops: Op[]): string {
  return ops
    .map((op) => {
      const code = OPCODES[op];
      return code.toString(16);
    })
    .join("");
}

export function evaluate(
  ops: SymExpr,
  stack: Rat[],
  opts?: { trace?: (ops: SymVal[], stack: Rat[]) => void; readSymbol?: (idx: number) => Rat },
) {
  const trace = opts?.trace;
  const readSymbol =
    opts?.readSymbol ??
    ((idx: number) => {
      throw Error(
        `unexpected attempt to read symbol index ${idx}; is a symbolic value being used where a concrete operation sequence was expected?`,
      );
    });

  // ops are evaluated left to right
  // the stack is written bottom/left top/right
  // values are pushed/popped from the top/right of the stack
  const pop = () => {
    return stack.pop() ?? int(0);
  };
  const peek = () => {
    return stack[stack.length - 1] ?? int(0);
  };
  const push = (x: Rat) => {
    stack.push(x);
  };
  for (let i = 0; i < ops.length; i++) {
    if (trace) {
      trace(ops.slice(i), [...stack]);
    }
    const opOrSymVal = ops[i];
    if (isSymbol(opOrSymVal)) {
      push(readSymbol(opOrSymVal[1]));
      continue;
    }
    // Not sure why we have to cast here; thought TypeScript would detect that
    // `op` is an `Op` after `isSymbol` check.
    const op = opOrSymVal as Op;
    switch (op) {
      case 0:
      case 1:
      case 2:
      case 3:
        push(int(op));
        break;
      case "+":
        push(add(pop(), pop()));
        break;
      case "-": {
        const b = pop();
        const a = pop();
        push(sub(a, b));
        break;
      }
      case "*":
        push(mul(pop(), pop()));
        break;
      case "/": {
        const b = pop();
        const a = pop();
        push(div(a, b));
        break;
      }
      case "%": {
        const b = pop();
        const a = pop();
        push(mod(a, b));
        break;
      }
      case "dup":
        push(peek());
        break;
      case "drop":
        pop();
        break;
      case "swap": {
        // Used to noop on underflow, but that made static analysis a lot more
        // complex stranger, and it seems inconsistent with other pop() used by
        // operators treating underflow as 0.
        const b = pop();
        const a = pop();
        push(b);
        push(a);
        break;
      }
      case "rot":
        if (stack.length > 1) {
          const t = stack[0];
          for (let i = 0; i < stack.length - 1; i++) {
            stack[i] = stack[i + 1];
          }
          stack[stack.length - 1] = t;
        }
        break;
      case "unrot":
        if (stack.length > 1) {
          const t = stack[stack.length - 1];
          for (let i = stack.length - 1; i > 0; i--) {
            stack[i] = stack[i - 1];
          }
          stack[0] = t;
        }
        break;
      case "len":
        push(int(stack.length));
        break;
      case "bgtz": {
        i++;
        if (i >= ops.length) {
          break;
        }
        const offsetOp = ops[i];
        if (isSymbol(offsetOp)) {
          throw Error(`unexpected symbol at bgtz offset index #${i}: ${unparse([offsetOp])}`);
        }
        const offset = OPCODES[offsetOp as Op];
        const e = pop();
        if (gtz(e)) {
          // Note that this means bgtz 0 is a noop.
          // I considered having bgtz N jump to N+1, but I think I'll save bgtz
          // 0 for use in the future, e.g. for syscalls?!
          i += offset;
        }
        break;
      }
      default:
        unreachable(op);
    }
  }
}

export type SymKind = "t" | "b" | "l";
export type Sym = [SymKind, number];
export type SymVal = Op | Sym;
export type SymExpr = SymVal[];
export type SymExprSet = SymExpr[];

export interface SymStack {
  top: SymExprSet[];
  bot: SymExprSet[];
  // top[top.length - 1] is the top of the stack
  // bot[bot.length - 1] is the bottom of the stack
  // top and bot never overlap, but there is un unknown number of items in the
  // middle
}

export const SymKind = {
  show(k: SymKind): string {
    if (k === "l") {
      return "ℓ";
    }
    return k;
  },
};

export const SymExpr = {
  toValue(expr: SymExpr): Rat | null {
    try {
      const stack: Rat[] = [];
      evaluate(expr, stack, {
        readSymbol() {
          throw "readSymbol";
        },
      });
      // Is it an error if we hit null here?
      return stack.pop() ?? null;
    } catch {
      return null;
    }
  },
};

export const SymExprSet = {
  toValueSet(exprs: SymExprSet): Set<Rat> | null {
    const out = new Set<Rat>();
    for (const expr of exprs) {
      const c = SymExpr.toValue(expr);
      if (c === null) {
        return null;
      }
      out.add(c);
    }
    return out;
  },
  isAlwaysGtz(exprs: SymExprSet): boolean {
    const cs = this.toValueSet(exprs);
    if (cs === null) {
      return false;
    }
    for (const c of cs) {
      if (!gtz(c)) {
        return false;
      }
    }
    return true;
  },
  show(es: SymExprSet): string {
    return "{" + es.map(unparse).join(", ") + "}";
  },
};

export const SymStack = {
  new(): SymStack {
    return { top: [], bot: [] };
  },
  lenLowerBound(self: SymStack): number {
    return self.top.length + self.bot.length;
  },
  show(self: SymStack): string {
    return (
      self.bot.toReversed().map(SymExprSet.show).join(" ") +
      " ⋯ " +
      self.top.map(SymExprSet.show).join(" ")
    );
  },
  top(self: SymStack): SymExprSet | undefined {
    return self.top[self.top.length - 1];
  },
  fromProgramHex(hex: string): SymStack {
    const ops = hexToOps(hex);
    const symStack: SymStack = SymStack.new();
    evaluateSym(ops, symStack);
    return symStack;
  },
  isSurelyConstant(self: SymStack): boolean {
    const nextExprSet = this.top(self);
    const nextValueSet = nextExprSet ? Array.from(SymExprSet.toValueSet(nextExprSet) ?? []) : [];
    return nextValueSet.length === 1;
  },
  isBoring(self: SymStack): boolean {
    const isConstant = this.isSurelyConstant(self);
    if (isConstant) {
      return true;
    }
    const topEs = self.top[self.top.length - 1];
    if (!topEs) {
      return true;
    }
    if (topEs.length === 1 && topEs[0].length === 1) {
      // e.g. ... {s_0}
      return true;
    }
    return false;
  },
  isConfusing(self: SymStack): boolean {
    const maxIdx: { [k in SymKind]: number } = {
      t: -1,
      b: -1,
      l: -1,
    };

    const top = this.top(self);
    if (!top) {
      return false;
    }

    for (const e of top) {
      for (const v of e) {
        if (isSymbol(v)) {
          const [k, n] = v;
          maxIdx[k] = Math.max(n, maxIdx[k]);
        }
      }
    }

    // If we see t_i, that means at most i+1 values were consumed from the top
    // of the stack
    if (maxIdx.t + maxIdx.b + 2 > SEED_LEN) {
      return true;
    }

    return false;
  },
};

type Gensym = (k: "b" | "t" | "l") => Sym;

export function evaluateSym(
  ops: Op[],
  stack: SymStack,
  opts?: { trace?: (ops: Op[], stack: SymStack) => void; gensym?: Gensym },
) {
  const trace = opts?.trace;
  const gensym: Gensym =
    opts?.gensym ??
    (() => {
      const idx: { [k in SymKind]: number } = {
        t: 0,
        b: 0,
        l: 0,
      };
      return (k: SymKind): Sym => {
        return [k, idx[k]++];
      };
    })();

  const pop = (): SymExprSet => {
    if (stack.top.length > 0) {
      return stack.top.pop()!;
    }
    stack.bot.shift();
    return [[gensym("t")]];
  };
  const push = (x: SymExprSet) => {
    stack.top.push(x);
  };
  for (let i = 0; i < ops.length; i++) {
    if (trace) {
      trace(ops.slice(i), structuredClone(stack));
    }
    const op = ops[i];
    switch (op) {
      case 0:
      case 1:
      case 2:
      case 3:
        push([[op]]);
        break;
      case "+":
      case "-":
      case "*":
      case "/":
      case "%": {
        const B = pop();
        const A = pop();

        const out: SymExprSet = [];

        // out = (x * y) op
        for (const b of B) {
          for (const a of A) {
            let c: SymExpr | null = null;

            // constant folding
            const x = SymExpr.toValue(a);
            const y = SymExpr.toValue(b);
            if (op === "+" || op === "-") {
              // x + 0 = x
              if (x && eq(x, ZERO)) {
                c = b;
              } else if (y && eq(y, ZERO)) {
                c = a;
              } else if (op === "-" && x && y && eq(x, y)) {
                c = [0];
              }
            } else if (op === "*") {
              // x * 1 = x
              if (x && eq(x, ONE)) {
                c = b;
              } else if (y && eq(y, ONE)) {
                c = a;
              }
            } else if (op === "/" && y && eq(y, ONE)) {
              // x / 1 = x
              c = a;
            } else if (x && y && eq(x, y)) {
              if (op === "/") {
                c = [1];
              } else if (op === "%") {
                c = [0];
              }
            } else if (((x && eq(x, ZERO)) || (y && eq(y, ZERO))) && (op === "/" || op === "%")) {
              // x / 0 = 0
              c = [0];
            }

            if (!c) {
              const ja = JSON.stringify(a);
              const jb = JSON.stringify(b);
              if (ja === jb) {
                if (op === "-") {
                  // x - x = 0
                  c = [0];
                } else if (op === "/") {
                  // x / x = 1
                  c = [1];
                }
              }
            }

            if (c) {
              out.push(c);
            } else {
              out.push([...a, ...b, op]);
            }
          }
        }

        // HACK: uniquify by JSON
        // Ideally we would handle e.g. commutativity
        const uniq = new Set<string>(out.map((e) => JSON.stringify(e)));
        push(Array.from(uniq.values()).map((j) => JSON.parse(j)));
        break;
      }
      case "dup": {
        const top = pop();
        push(top);
        push(top);
        break;
      }
      case "drop":
        pop();
        break;
      case "swap": {
        const b = pop();
        const a = pop();
        push(b);
        push(a);
        break;
      }
      case "rot":
        if (stack.bot.length > 0) {
          const bot = stack.bot.pop()!;
          push(bot);
        } else {
          stack.top.shift();
          push([[gensym("b")]]);
        }
        break;
      case "unrot": {
        if (stack.top.length === 0) {
          stack.bot.shift();
        }
        stack.bot.push(pop());
        break;
      }
      case "len":
        push([[gensym("l")]]);
        break;
      case "bgtz": {
        i++;
        if (i >= ops.length) {
          break;
        }
        const offsetOp = ops[i++];
        const offset = OPCODES[offsetOp];
        const e = pop();

        if (SymExprSet.isAlwaysGtz(e)) {
          i += offset;
          break;
        }

        const trueOps = ops.slice(i + offset);
        const trueStack = structuredClone(stack);
        evaluateSym(trueOps, trueStack, { trace, gensym });

        const falseOps = ops.slice(i);
        const falseStack = structuredClone(stack);
        evaluateSym(falseOps, falseStack, { trace, gensym });

        // merge trueStack and falseStack
        const merge = (k: SymKind, left: SymExprSet[], right: SymExprSet[]): SymExprSet[] => {
          const out: SymExprSet[] = [];
          const len = Math.max(left.length, right.length);
          for (let i = 0; i < len; i++) {
            const exprs = new Set<string>();
            if (left.length > 0) {
              for (const x of left.pop()!) {
                exprs.add(JSON.stringify(x));
              }
            } else {
              exprs.add(JSON.stringify([gensym(k)]));
            }
            if (right.length > 0) {
              for (const x of right.pop()!) {
                exprs.add(JSON.stringify(x));
              }
            } else {
              exprs.add(JSON.stringify([gensym(k)]));
            }
            // todo merge identical values more generally
            out.push(Array.from(exprs).map((x) => JSON.parse(x)));
          }
          out.reverse();
          return out;
        };

        // console.log(
        //   `merging ${JSON.stringify(trueStack.top)} and ${JSON.stringify(falseStack.top)}`,
        // );
        stack.top = merge("t", trueStack.top, falseStack.top);
        stack.bot = merge("b", trueStack.bot, falseStack.bot);
        // console.log(`got ${JSON.stringify(stack.top)}`);
        return;
      }
      default:
        unreachable(op);
    }
  }
}
